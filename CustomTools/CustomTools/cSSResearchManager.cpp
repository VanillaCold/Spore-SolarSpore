#include "stdafx.h"
#include "cSSResearchManager.h"
#include "CloseResearchMenu.h"
#include "cResearchWinProc.h"
#include "cResearchButtonWinProc.h"

/// AUTOGENERATED METHODS ///

int cSSResearchManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cSSResearchManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cSSResearchManager::GetName() const {
	return "CustomTools::cSSResearchManager";
}

bool cSSResearchManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cSSResearchManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cSSResearchManager::WriteToXML(Simulator::XmlSerializer* writexml)
{
	return false;
}


/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cSSResearchManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	SimAttribute(cSSResearchManager,mResearchPoints,1),
	Simulator::Attribute()
};

void cSSResearchManager::Initialize() {
	mResearchPoints = 0;
	sInstance = this;
	mpUIlayout = nullptr;
	SetupResearches();
}

void cSSResearchManager::Dispose() {
	
}

void cSSResearchManager::Update(int deltaTime, int deltaGameTime) 
{
	if (Simulator::IsSpaceGame())
	{
		mResearchPoints += deltaGameTime * Simulator::SpacePlayerData::Get()->mPlayerColonies.size() / 1000 / 60;

		if (mpPointsCaption)
		{
			string16 cap;
			cap.assign_convert(to_string(int(floor(mResearchPoints))));
			cap = u"\u268C " + cap;
			mpPointsCaption->SetCaption(cap.c_str());
		}

		if (mWindowOffset != 0 && mpUIlayout)
		{
			auto window = mpUIlayout->FindWindowByID(0xFFFFFFFF, false);
			float offset2 = (((mWindowOffset * -1) + 1) / 8); //max((((windowOffset * -1) + 1) / 8), 1.0)
			mWindowOffset = mWindowOffset + offset2;

			UTFWin::IWindow* parentWindow = window->GetParent();
			Math::Rectangle rec = parentWindow->GetArea();
			window->SetArea(Math::Rectangle(rec.right / 2 - (801 / 2), (rec.bottom / 2 - (602 / 2)) + mWindowOffset, rec.right / 2 + (801 / 2), (rec.bottom / 2 + (602 / 2)) + mWindowOffset));
		}
	}
	else
	{
		if (mpUIlayout)
		{
			CloseResearchUI(false);
		}
	}
}

cSSResearchManager* cSSResearchManager::Get()
{
	return sInstance;
}

bool cSSResearchManager::CheckResearchExists(uint32_t resID)
{
	for (int i = 0; i < mResearchTypes.size(); i++)
	{
		if (mResearchTypes[i].mResearchID == resID)
		{
			return true;
		}
	}
	return false;
}

bool cSSResearchManager::HasResearched(uint32_t resID)
{
	ResearchType& res = GetResearch(resID);
	if (res)
	{
		if (SimulatorSpaceGame.GetPlayerInventory()->HasTool({ res.mToolID,0,0 }))
		{
			return true;
		}
	}
	return false;
}

bool cSSResearchManager::ResearchItem(uint32_t resID, string& outError)
{
	
	if (ResearchType& res = GetResearch(resID))
	{
		auto inv = SimulatorSpaceGame.GetPlayerInventory();
		if (inv->HasTool({ res.mToolID,0,0 }))
		{
			outError = "Already researched.";
			return false;
		}

		if (mResearchPoints < res.mRequiredPoints)
		{
			outError = "Not enough research points.";
			return false;
		}
		for each (uint32_t priorID in res.mPriorResearches)
		{
			if (!HasResearched(priorID))
			{
				outError = "Not all prior researches are researched.";
				return false;
			}
		}
		
		cSpaceToolDataPtr pTool;
		if (ToolManager.LoadTool({ res.mToolID,0,0 }, pTool))
		{
			inv->AddItem(pTool.get());
			mResearchPoints -= res.mRequiredPoints;
			return true;
		}
	}
	return false;
}

ResearchType& cSSResearchManager::GetResearch(uint32_t resID)
{
	for (int i = 0; i < mResearchTypes.size(); i++)
	{
		if (mResearchTypes[i].mResearchID == resID)
		{
			return mResearchTypes[i];
		}
	}
	return ResearchType(0);
}

// UI functions

bool cSSResearchManager::OpenResearchUI(bool animation)
{
	if (!mpUIlayout)
	{
		mpUIlayout = new UTFWin::UILayout();
	}

	if (mpUIlayout->LoadByID(id("ResearchScreen")))
	{
		mpUIlayout->SetVisible(true);
		mpUIlayout->SetParentWindow(WindowManager.GetMainWindow());
		auto window = mpUIlayout->FindWindowByID(0xFFFFFFFF, false);
		window->SetSize(801.0F, 602.0F);
		WindowManager.GetMainWindow()->SendToBack(mpUIlayout->GetContainerWindow());

		Math::Rectangle rec = window->GetParent()->GetArea();

		if (animation)
		{
			mWindowOffset = (rec.bottom / 2 + (602 / 2));
		}
		else
		{
			mWindowOffset = 0;
		}

		window->SetArea(Math::Rectangle(rec.right / 2 - (801 / 2), (rec.bottom / 2 - (602 / 2)) + mWindowOffset, rec.right / 2 + (801 / 2), (rec.bottom / 2 + (602 / 2)) + mWindowOffset));

		auto closeButton = mpUIlayout->FindWindowByID(id("closebutton"));
		closeButton->AddWinProc(new CloseResearchMenu());

		auto resButton = mpUIlayout->FindWindowByID(id("ResearchButton"));
		resButton->AddWinProc(new cResearchWinProc());

		mpPointsCaption = mpUIlayout->FindWindowByID(id("RSPointCounter"));

		auto nameCaption = mpUIlayout->FindWindowByID(id("ResName"));
		nameCaption->SetCaption(u"");

		auto descCaption = mpUIlayout->FindWindowByID(id("ResDescr"));
		descCaption->SetCaption(u"");

		LoadUIItems();

		return true;
	}
	mpUIlayout = nullptr;
	return false;
}

bool cSSResearchManager::CloseResearchUI(bool animation)
{
	if (mpUIlayout)
	{
		mWindowOffset = 0;
		WindowManager.GetMainWindow()->RemoveWindow(mpUIlayout->FindWindowByID(0xFFFFFFFF, false));
		mpPointsCaption = false;
		mpUIlayout = nullptr;
		return true;
	}
	return false;
}



void cSSResearchManager::LoadUIItems()
{
	auto inventoryWindow = mpUIlayout->FindWindowByID(id("Inventory"), true);
	int i = 0;
	for each (ResearchType research in mResearchTypes)
	{
		if (!HasResearched(research.mResearchID))
		{
			UTFWin::UILayout* layout = new UTFWin::UILayout();
			layout->LoadByID(id("ResearchItem"));
			layout->SetParentWindow(inventoryWindow);

			layout->SetVisible(true);


			if (auto itemWindow = layout->FindWindowByID(id("ItemID")))
			{
				itemWindow->SetFlag(UTFWin::WindowFlags::kWinFlagAlwaysInFront, true);
				itemWindow->FindWindowByID(id("itembutton"))->AddWinProc(new cResearchButtonWinProc(itemWindow, research));
				itemWindow->SetLayoutLocation((65 * (i % 8)) + (8 * ((i % 8)+1)), div((i),8).quot * 65);

				auto icon = itemWindow->FindWindowByID(id("ItemIcon"));

				ResourceKey imgKey;
				if (App::Property::GetKey(research.mpPropList.get(), id("ResearchImage"), imgKey))
				{
					ImagePtr img;
					if (Image::GetImage(imgKey, img))
					{
						ImageDrawable* drawable = new ImageDrawable();
						drawable->SetImage(img.get());
						icon->SetDrawable(drawable);
					}
				}



				mpItemUIs.push_back(itemWindow);
				i++;
			}
		}
	}

}

//Private functions

bool cSSResearchManager::SetupResearches()
{
	vector<uint32_t> researchIDs;
	PropManager.GetPropertyListIDs(id("SS-research"), researchIDs);

	for each (uint32_t resID in researchIDs)
	{
		try
		{
			ResearchType res = ResearchType(resID);
			mResearchTypes.push_back(res);
		}
		catch (std::exception except)
		{
			const char* text = except.what();
			wstring report;
			report.assign_convert(text);
			MessageBox(NULL, report.c_str(), LPCWSTR(u"Error adding research"), 0x00000010L);
		}
	}
	return false;
}

cSSResearchManager* cSSResearchManager::sInstance;


//Struct con-struct-or
ResearchType::ResearchType(uint32_t propID)
{
	if (propID == 0)
	{
		mRequiredPoints = 0;
		mResearchID = 0;
		mToolID = 0;
		return;
	}

	if (PropManager.GetPropertyList(propID, id("SS-research"), mpPropList))
	{
		mResearchID = propID;
		App::Property::GetUInt32(mpPropList.get(), id("ResearchTool"), mToolID);

		App::Property::GetText(mpPropList.get(), id("ResearchName"), mResearchTitle);
		App::Property::GetText(mpPropList.get(), id("ResearchDescript"), mResearchDescription);

		size_t count;
		uint32_t* ids;
		App::Property::GetArrayUInt32(mpPropList.get(), id("ResearchDependancies"), count, ids);
		if (count != 0)
		{
			for (int i = 0; i < count; i++)
			{
				mPriorResearches.push_back(ids[i]);
			}
		}

		if (!App::Property::GetUInt32(mpPropList.get(), id("ResearchPointsRequired"), mRequiredPoints))
		{
			string error = "Research property list " + to_string(propID) + " has no required point count!";
			throw std::invalid_argument(error.c_str());
		}
	}
	else
	{
		string error = "Research property list " + to_string(propID) + " is not valid!";
		throw std::invalid_argument(error.c_str());
	}
}

ResearchType::ResearchType()
{
	mRequiredPoints = 0;
	mResearchID = 0;
	mToolID = 0;
}

const bool ResearchType::operator==(const ResearchType other)
{
	return other.mpPropList == mpPropList && other.mPriorResearches == mPriorResearches
		&& other.mRequiredPoints == mRequiredPoints && other.mToolID == mToolID && mResearchID == other.mResearchID;
}

const bool ResearchType::operator!=(const ResearchType other)
{
	return !(other.mpPropList == mpPropList && other.mPriorResearches == mPriorResearches
		&& other.mRequiredPoints == mRequiredPoints && other.mToolID == mToolID && other.mResearchID == mResearchID);
}

ResearchType::operator bool() const
{
	return (mResearchID != 0);
}
