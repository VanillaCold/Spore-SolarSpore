#include "stdafx.h"
#include "cSSResearchManager.h"

/// AUTOGENERATED METHODS ///

int cSSResearchManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cSSResearchManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cSSResearchManager::GetName() const {
	return "CustomTools::cSSResearchManager";
}

bool cSSResearchManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cSSResearchManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

bool cSSResearchManager::WriteToXML(Simulator::XmlSerializer* writexml)
{
	return false;
}


/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cSSResearchManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	SimAttribute(cSSResearchManager,mResearchPoints,1),
	Simulator::Attribute()
};

void cSSResearchManager::Initialize() {
	mResearchPoints = 0;
	sInstance = this;
	SetupResearches();
}

void cSSResearchManager::Dispose() {
	
}

void cSSResearchManager::Update(int deltaTime, int deltaGameTime) 
{
	
}

cSSResearchManager* cSSResearchManager::Get()
{
	return sInstance;
}

bool cSSResearchManager::CheckResearchExists(uint32_t resID)
{
	for (int i = 0; i < mResearchTypes.size(); i++)
	{
		if (mResearchTypes[i].mResearchID == resID)
		{
			return true;
		}
	}
	return false;
}

bool cSSResearchManager::HasResearched(uint32_t resID)
{
	ResearchType& res = GetResearch(resID);
	if (res)
	{
		if (SimulatorSpaceGame.GetPlayerInventory()->HasTool({ res.mToolID,0,0 }))
		{
			return true;
		}
	}
	return false;
}

bool cSSResearchManager::ResearchItem(uint32_t resID, string& outError)
{
	
	if (ResearchType& res = GetResearch(resID))
	{
		auto inv = SimulatorSpaceGame.GetPlayerInventory();
		if (inv->HasTool({ res.mToolID,0,0 }))
		{
			outError = "Already researched.";
			return false;
		}

		if (mResearchPoints < res.mRequiredPoints)
		{
			outError = "Not enough research points.";
			return false;
		}
		for each (uint32_t priorID in res.mPriorResearches)
		{
			if (!HasResearched(priorID))
			{
				outError = "Not all prior researches are researched.";
				return false;
			}
		}
		
		cSpaceToolDataPtr pTool;
		if (ToolManager.LoadTool({ res.mToolID,0,0 }, pTool))
		{
			inv->AddItem(pTool.get());
			return true;
		}
	}
	return false;
}

ResearchType& cSSResearchManager::GetResearch(uint32_t resID)
{
	for (int i = 0; i < mResearchTypes.size(); i++)
	{
		if (mResearchTypes[i].mResearchID == resID)
		{
			return mResearchTypes[i];
		}
	}
	return ResearchType(0);
}

bool cSSResearchManager::SetupResearches()
{
	vector<uint32_t> researchIDs;
	PropManager.GetPropertyListIDs(id("SS-research"), researchIDs);

	for each (uint32_t resID in researchIDs)
	{
		try
		{
			ResearchType res = ResearchType(resID);
			mResearchTypes.push_back(res);
		}
		catch (std::exception except)
		{
			const char* text = except.what();
			wstring report;
			report.assign_convert(text);
			MessageBox(NULL, report.c_str(), LPCWSTR(u"Error adding research"), 0x00000010L);
		}
	}
	return false;
}

cSSResearchManager* cSSResearchManager::sInstance;


//Struct con-struct-or
ResearchType::ResearchType(uint32_t propID)
{
	if (propID == 0)
	{
		mRequiredPoints = 0;
		mResearchID = 0;
		mToolID = 0;
		return;
	}

	if (PropManager.GetPropertyList(propID, id("SS-research"), mpPropList))
	{
		mResearchID = propID;
		App::Property::GetUInt32(mpPropList.get(), id("ResearchTool"), mToolID);

		size_t count;
		uint32_t* ids;
		App::Property::GetArrayUInt32(mpPropList.get(), id("ResearchDependancies"), count, ids);
		if (count != 0)
		{
			for (int i = 0; i < count; i++)
			{
				mPriorResearches.push_back(ids[i]);
			}
		}

		if (!App::Property::GetUInt32(mpPropList.get(), id("ResearchPointsRequired"), mRequiredPoints))
		{
			string error = "Research property list " + to_string(propID) + " has no required point count!";
			throw std::invalid_argument(error.c_str());
		}
	}
	else
	{
		string error = "Research property list " + to_string(propID) + " is not valid!";
		throw std::invalid_argument(error.c_str());
	}
}

const bool ResearchType::operator==(const ResearchType other)
{
	return other.mpPropList == mpPropList && other.mPriorResearches == mPriorResearches
		&& other.mRequiredPoints == mRequiredPoints && other.mToolID == mToolID && mResearchID == other.mResearchID;
}

const bool ResearchType::operator!=(const ResearchType other)
{
	return !(other.mpPropList == mpPropList && other.mPriorResearches == mPriorResearches
		&& other.mRequiredPoints == mRequiredPoints && other.mToolID == mToolID && other.mResearchID == mResearchID);
}

ResearchType::operator bool() const
{
	return (mResearchID != 0);
}
