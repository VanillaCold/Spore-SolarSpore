#include "stdafx.h"
#include "cSSStatusEffectManager.h"

/// AUTOGENERATED METHODS ///

int cSSStatusEffectManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cSSStatusEffectManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cSSStatusEffectManager::GetName() const {
	return "CustomTools::cSSStatusEffectManager";
}

bool cSSStatusEffectManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cSSStatusEffectManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cSSStatusEffectManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

void cSSStatusEffectManager::Initialize() {
	sInstance = this;
	activeStatusEffects = map < uint32_t, IStatusEffect*> ();
}

void cSSStatusEffectManager::Dispose() {
	
}

void cSSStatusEffectManager::Update(int deltaTime, int deltaGameTime) {
	vector<uint32_t> invalidStatuses{};
	for(auto i = activeStatusEffects.begin(); i != activeStatusEffects.end();i++)
	{
		auto statusID = i.mpNode->mValue.first;
		auto status = i.mpNode->mValue.second;
		if (status == nullptr)
		{
			SporeDebugPrint("well the effect died.");
			invalidStatuses.push_back(statusID);
		}

		else if (status->mbIsFinished)
		{
			SporeDebugPrint("wooeeoo");
			invalidStatuses.push_back(statusID);
		}
		else
		{
			status->Update(deltaGameTime / 1000.0f);
		}
	}

	for each (uint32_t removal in invalidStatuses)
	{
		if (activeStatusEffects[removal] != nullptr)
		{
			activeStatusEffects[removal]->EndEffect();
		}
		activeStatusEffects.erase(removal);
	}
}

bool cSSStatusEffectManager::WriteToXML(Simulator::XmlSerializer* writexml)
{
	return false;
}

cSSStatusEffectManager* cSSStatusEffectManager::Get()
{
	return sInstance;
}

void cSSStatusEffectManager::AddStatusEffect(cCombatantPtr combatant, uint32_t instanceID, cCombatantPtr source, cSpaceToolDataPtr pTool)
{
	//Get the property list from the status effect's instance ID.
	PropertyListPtr propList;
	PropManager.GetPropertyList(instanceID, id("SS-StatusEffects"), propList);
	
	//Next, get the status effect strategy to use.
	uint32_t statusType;
	App::Property::GetUInt32(propList.get(), id("statusEffectType"), statusType);
	
	//Log stuff.
	ModAPI::Log("Adding status effect with strat. ID %x", statusType);

	//If the strategy exists,
	if (statusTypes[statusType] != nullptr)
	{
		//log stuff again.
		ModAPI::Log("Strategy does indeed exist");


		//Set the index to 0.
		uint32_t index = 0;
		index = GetRNG().RandomInt(0xFFFFFFFF);

		//next, check if this status is already being used by that specific combatant
		for (auto i = activeStatusEffects.begin(); i != activeStatusEffects.end(); i++)
		{
			auto effect = i.mpNode->mValue;
			if (effect.second->mpCombatant.get() == combatant.get() && instanceID == effect.second->mStatusEffectID && !effect.second->mbIsFinished)
			{
				//If it is, then reset its timer - don't remove it.
				effect.second->mTimer = 0;
				App::Property::GetFloat(propList.get(), id("statusEffectTimer"), effect.second->mTimer);
				ModAPI::Log("Restoring timer on existing combatant.");
				return;
			}
		}
		//If not...
		//Clone the template status strategy,
		IStatusEffect* status = statusTypes[statusType]->Clone();
		//and instantiate it with the status effect ID, and the combatant.
		status->Instantiate(instanceID, combatant, source);

		//set the strategy's internal index,
		status->mInternalID = index;
		status->mpToolObject = pTool;
		//then finally add it to the list of active effects.
		activeStatusEffects.emplace(status->mInternalID, status);
	}
}

IStatusEffect* cSSStatusEffectManager::FindStatusEffect(cCombatantPtr pTarget, uint32_t effID)
{
	for (auto i = activeStatusEffects.begin(); i != activeStatusEffects.end(); i++)
	{
		auto effect = i.mpNode->mValue;
		if (effect.second->mpCombatant.get() == pTarget.get() && effID == effect.second->mStatusEffectID && !effect.second->mbIsFinished)
		{
			return effect.second;
		}
	}
	return nullptr;
}

vector<IStatusEffect*> cSSStatusEffectManager::FindStatusEffectByClass(cCombatantPtr pTarget, uint32_t pClassID, uint32_t pWhitelistType)
{
	vector<IStatusEffect*> allEffects;
	for (auto i = activeStatusEffects.begin(); i != activeStatusEffects.end(); i++)
	{
		auto effect = i.mpNode->mValue;
		if (effect.second)
		{
			if (effect.second->mpCombatant.get() == pTarget.get() && effect.second->Cast(pClassID))
			{
				if (effect.second->mStatusType != pWhitelistType)
				{
					allEffects.push_back(effect.second);
				}
			}
		}
	}
	return allEffects;
}

void cSSStatusEffectManager::RemoveStatusEffect(cCombatantPtr pTarget, uint32_t effID)
{
	for (auto i = activeStatusEffects.begin(); i != activeStatusEffects.end(); i++)
	{
		auto effect = i.mpNode->mValue;
		if (effect.second->mpCombatant.get() == pTarget.get() && effID == effect.second->mStatusEffectID && !effect.second->mbIsFinished)
		{
			effect.second->mbIsFinished = true;
			return;
		}
	}
	return;
}

void cSSStatusEffectManager::AddStatusType(IStatusEffect* type, uint32_t typeID)
{
	ModAPI::Log("Added strategy with ID %x", typeID);
	type->mbIsExample = true;
	statusTypes.emplace(typeID, type);
}

cSSStatusEffectManager* cSSStatusEffectManager::sInstance;